#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcElecCap
# Date:         01.14.2023
# Author:       Dr. Pascal A. Schirmer
# Version:      V.0.1
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
import pandas as pd
from scipy import interpolate
from scipy.fft import fft
from scipy import signal

#######################################################################################################################
# Function
#######################################################################################################################
def calcElecCap(t, i_c, Tj, para, setupPara, setupTopo):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    dt = t[1] - t[0]
    fel = setupTopo['fel']

    # ==============================================================================
    # Variables
    # ==============================================================================
    f = np.linspace(0, int(1/dt), int(len(i_c)/2))
    t = np.linspace(0, 2/fel, len(i_c)*2-1)

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Double i_c
    # ==============================================================================
    i_c = np.concatenate((i_c[0:-1], i_c),axis=0)

    # ==============================================================================
    # Get Fundamentel Frequency
    # ==============================================================================
    idx = np.argmin(f-2*fel)

    # ==============================================================================
    # Extract Parameters
    # ==============================================================================
    # ------------------------------------------
    # Constant
    # ------------------------------------------
    if setupPara['Elec']['CapMdl'] == "con" or setupPara['Elec']['SwiMdl'] == "pwl":  
        ESR = para['Cap']['Elec']['con']['ESR']
        C = para['Cap']['Elec']['con']['C']
        
    # ------------------------------------------
    # Tabular
    # ------------------------------------------
    if setupPara['Elec']['CapMdl'] == "tab":
        # Matrix 
        ESR_2d = interpolate.interp2d(para['Cap']['Elec']['vec']['Tj'].to_numpy(), para['Cap']['Elec']['vec']['f'].to_numpy(), para['Cap']['Elec']['tab']['ESR'].to_numpy(), kind='linear')
        C_2d = interpolate.interp2d(para['Cap']['Elec']['vec']['Tj'].to_numpy(), para['Cap']['Elec']['vec']['f'].to_numpy(), para['Cap']['Elec']['tab']['C'].to_numpy(), kind='linear')

        # Fundamental Value
        ESR = ESR_2d(Tj, f[idx])
        C = C_2d(Tj, f[idx])

        # Static
        ESR = ESR[0]
        C = C[0]

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    tf = signal.TransferFunction([ESR*C, 1], [C, 0])
    _, v_dc, _, = signal.lsim(tf, i_c, t)

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    v_dc = v_dc[int(len(i_c)/2)-1:-1]

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return v_dc